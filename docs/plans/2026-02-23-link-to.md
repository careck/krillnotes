# `link_to` View Function + Navigation History Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add a `link_to(note)` Rhai display helper that renders clickable note links in custom views, with a full navigation history stack and back button in the InfoPanel.

**Architecture:** `link_to(note: Map) → str` generates an `<a class="kn-view-link" data-note-id="...">` anchor in Rust; the React InfoPanel intercepts clicks via event delegation and calls a new `onLinkNavigate(noteId)` callback in WorkspaceView; WorkspaceView owns a `viewHistory: string[]` stack that is populated on link navigation and cleared on tree/manual navigation; InfoPanel receives a computed `backNoteTitle` string and renders a back button above the view content whenever it is defined.

**Tech Stack:** Rust/Rhai (display_helpers.rs, mod.rs), React/TypeScript (WorkspaceView.tsx, InfoPanel.tsx), CSS (globals.css)

---

### Task 1: Add `link_to` Rust function with unit tests

**Files:**
- Modify: [krillnotes-core/src/core/scripting/display_helpers.rs](krillnotes-core/src/core/scripting/display_helpers.rs)

**Step 1: Write the failing unit tests**

At the bottom of `display_helpers.rs`, add a `#[cfg(test)]` module:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use rhai::Map;

    fn make_note_map(id: &str, title: &str) -> Map {
        let mut m = Map::new();
        m.insert("id".into(),    rhai::Dynamic::from(id.to_string()));
        m.insert("title".into(), rhai::Dynamic::from(title.to_string()));
        m
    }

    #[test]
    fn test_link_to_renders_anchor_with_id_and_title() {
        let m = make_note_map("abc-123", "My Note");
        let html = link_to(m);
        assert!(html.contains(r#"class="kn-view-link""#));
        assert!(html.contains(r#"data-note-id="abc-123""#));
        assert!(html.contains("My Note"));
    }

    #[test]
    fn test_link_to_escapes_title() {
        let m = make_note_map("id-1", "<script>alert('xss')</script>");
        let html = link_to(m);
        assert!(!html.contains("<script>"), "raw <script> tag must not appear in output");
        assert!(html.contains("&lt;script&gt;"));
    }

    #[test]
    fn test_link_to_escapes_id() {
        let m = make_note_map(r#"id"with"quotes"#, "Title");
        let html = link_to(m);
        assert!(!html.contains(r#"id"with"quotes"#), "raw quotes in id must be escaped");
    }

    #[test]
    fn test_link_to_empty_map_returns_anchor_with_empty_values() {
        let m = Map::new();
        let html = link_to(m);
        // Should not panic; should return a valid (empty-attribute) anchor
        assert!(html.contains("kn-view-link"));
    }
}
```

**Step 2: Run tests to confirm they fail**

```bash
cargo test -p krillnotes-core link_to 2>&1 | head -30
```

Expected: error — `link_to` not found.

**Step 3: Implement `link_to`**

Add this function after the `divider()` function (before the `// ── Utilities` section) in `display_helpers.rs`:

```rust
/// Renders a clickable link to another note.
///
/// When clicked in the view panel, the app navigates to the linked note.
/// Navigation history is tracked so the user can press the back button
/// to return.
///
/// ```rhai
/// link_to(get_note(some_id))
/// // or within a loop:
/// contacts.map(|c| link_to(c))
/// ```
pub fn link_to(note: Map) -> String {
    let id = note
        .get("id")
        .and_then(|v| v.clone().into_string().ok())
        .unwrap_or_default();
    let title = note
        .get("title")
        .and_then(|v| v.clone().into_string().ok())
        .unwrap_or_default();
    format!(
        r#"<a class="kn-view-link" data-note-id="{}">{}</a>"#,
        html_escape(&id),
        html_escape(&title),
    )
}
```

**Step 4: Run tests to confirm they pass**

```bash
cargo test -p krillnotes-core link_to 2>&1
```

Expected: all 4 tests PASS.

---

### Task 2: Register `link_to` in the Rhai engine + integration test

**Files:**
- Modify: [krillnotes-core/src/core/scripting/mod.rs](krillnotes-core/src/core/scripting/mod.rs)

**Step 1: Register the function**

In `mod.rs`, in the `// ── Display helpers for on_view hooks` block (around line 161), add one line after `divider`:

```rust
        engine.register_fn("link_to", display_helpers::link_to);
```

The full block should look like:
```rust
        engine.register_fn("table",   display_helpers::table);
        engine.register_fn("section", display_helpers::section);
        engine.register_fn("stack",   display_helpers::stack);
        engine.register_fn("columns", display_helpers::columns);
        engine.register_fn("field",   display_helpers::field_row);
        engine.register_fn("fields",  display_helpers::fields);
        engine.register_fn("heading", display_helpers::heading);
        engine.register_fn("text",    display_helpers::view_text);
        engine.register_fn("list",    display_helpers::list);
        engine.register_fn("badge",   display_helpers::badge);
        engine.register_fn("badge",   display_helpers::badge_colored);
        engine.register_fn("divider", display_helpers::divider);
        engine.register_fn("link_to", display_helpers::link_to);
```

**Step 2: Write an integration test**

Add this test to the `#[cfg(test)] mod tests` block at the bottom of `mod.rs`, after the existing `test_contact_on_save_hook_derives_title` test:

```rust
    #[test]
    fn test_link_to_is_callable_from_on_view_script() {
        use crate::{FieldValue, Note};
        use std::collections::HashMap;

        let mut registry = ScriptRegistry::new().unwrap();
        registry.load_script(r#"
            schema("LinkTest", #{
                fields: [#{ name: "ref_id", type: "text" }]
            });
            on_view("LinkTest", |note| {
                let target = #{ id: "target-id-123", title: "Target Note", fields: #{}, node_type: "TextNote" };
                link_to(target)
            });
        "#).unwrap();

        let note = Note {
            id: "note-1".to_string(),
            node_type: "LinkTest".to_string(),
            title: "Test".to_string(),
            parent_id: None,
            position: 0,
            created_at: 0,
            modified_at: 0,
            created_by: 0,
            modified_by: 0,
            fields: HashMap::new(),
            is_expanded: false,
        };

        let context = QueryContext {
            notes_by_id: HashMap::new(),
            children_by_id: HashMap::new(),
            notes_by_type: HashMap::new(),
        };

        let result = registry.run_on_view_hook(&note, context).unwrap();
        assert!(result.is_some());
        let html = result.unwrap();
        assert!(html.contains("kn-view-link"));
        assert!(html.contains("target-id-123"));
        assert!(html.contains("Target Note"));
    }
```

**Step 3: Run the integration test**

```bash
cargo test -p krillnotes-core test_link_to_is_callable 2>&1
```

Expected: PASS.

**Step 4: Run the full Rust test suite**

```bash
cargo test -p krillnotes-core 2>&1 | tail -20
```

Expected: all tests PASS, no regressions.

**Step 5: Commit**

```bash
git add krillnotes-core/src/core/scripting/display_helpers.rs \
        krillnotes-core/src/core/scripting/mod.rs
git commit -m "feat(core): add link_to display helper for on_view hooks"
```

---

### Task 3: Add `viewHistory` state and callbacks to WorkspaceView

**Files:**
- Modify: [krillnotes-desktop/src/components/WorkspaceView.tsx](krillnotes-desktop/src/components/WorkspaceView.tsx)

No frontend test framework exists — verify correctness by building the app.

**Step 1: Add `viewHistory` state**

After line 25 (`const [selectedNoteId, setSelectedNoteId] = useState<string | null>(null);`), add:

```typescript
  const [viewHistory, setViewHistory] = useState<string[]>([]);
```

**Step 2: Add `handleLinkNavigate` callback**

After the `handleSelectNote` function (around line 152), add:

```typescript
  const handleLinkNavigate = (noteId: string) => {
    if (selectedNoteId) {
      setViewHistory(h => [...h, selectedNoteId]);
    }
    setSelectedNoteId(noteId);
    invoke('set_selected_note', { noteId }).catch(err =>
      console.error('Failed to save selection:', err)
    );
  };
```

**Step 3: Add `handleBack` callback**

After `handleLinkNavigate`, add:

```typescript
  const handleBack = () => {
    setViewHistory(h => {
      if (h.length === 0) return h;
      const prev = h[h.length - 1];
      setSelectedNoteId(prev);
      invoke('set_selected_note', { noteId: prev }).catch(err =>
        console.error('Failed to save selection:', err)
      );
      return h.slice(0, -1);
    });
  };
```

**Step 4: Clear history on tree/manual navigation**

In the existing `handleSelectNote` function (line 152), add `setViewHistory([])` at the top:

```typescript
  const handleSelectNote = async (noteId: string) => {
    setViewHistory([]);          // ← add this line
    setSelectedNoteId(noteId);
    try {
      await invoke('set_selected_note', { noteId });
    } catch (err) {
      console.error('Failed to save selection:', err);
    }
  };
```

**Step 5: Compute `backNoteTitle` and pass new props to InfoPanel**

Just above the `return (` statement (after line 372's `const pendingDeleteNote = ...`), add:

```typescript
  const backNoteTitle = viewHistory.length > 0
    ? (notes.find(n => n.id === viewHistory[viewHistory.length - 1])?.title ?? '…')
    : undefined;
```

Then in the `<InfoPanel ...>` JSX (around line 423), add the three new props:

```tsx
        <InfoPanel
          selectedNote={selectedNote}
          onNoteUpdated={handleNoteUpdated}
          onDeleteRequest={handleDeleteRequest}
          requestEditMode={requestEditMode}
          onEditDone={handleEditDone}
          onLinkNavigate={handleLinkNavigate}
          onBack={handleBack}
          backNoteTitle={backNoteTitle}
        />
```

---

### Task 4: Add back button and click delegation to InfoPanel

**Files:**
- Modify: [krillnotes-desktop/src/components/InfoPanel.tsx](krillnotes-desktop/src/components/InfoPanel.tsx)

**Step 1: Extend `InfoPanelProps` interface**

In the `InfoPanelProps` interface (line 9), add three new props:

```typescript
interface InfoPanelProps {
  selectedNote: Note | null;
  onNoteUpdated: () => void;
  onDeleteRequest: (noteId: string) => void;
  requestEditMode: number;
  onEditDone: () => void;
  onLinkNavigate: (noteId: string) => void;
  onBack: () => void;
  backNoteTitle?: string;
}
```

**Step 2: Destructure new props**

In the function signature (line 35), extend the destructuring:

```typescript
function InfoPanel({ selectedNote, onNoteUpdated, onDeleteRequest, requestEditMode, onEditDone, onLinkNavigate, onBack, backNoteTitle }: InfoPanelProps) {
```

**Step 3: Add back button above the Fields Section**

In the JSX, just before the `{/* Fields Section */}` comment (line 287), add:

```tsx
      {/* Back navigation — shown whenever history is non-empty, regardless of view type */}
      {!isEditing && backNoteTitle !== undefined && (
        <div className="kn-view-back">
          <button onClick={onBack}>← Back to "{backNoteTitle}"</button>
        </div>
      )}
```

**Step 4: Add click delegation to the custom view HTML div**

Find the existing custom view div (around line 289):

```tsx
        {!isEditing && customViewHtml && (
          <div
            dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(customViewHtml) }}
          />
        )}
```

Replace it with:

```tsx
        {!isEditing && customViewHtml && (
          <div
            dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(customViewHtml) }}
            onClick={(e) => {
              const link = (e.target as Element).closest('.kn-view-link');
              if (link) {
                e.preventDefault();
                const noteId = link.getAttribute('data-note-id');
                if (noteId) onLinkNavigate(noteId);
              }
            }}
          />
        )}
```

---

### Task 5: Add CSS for `kn-view-link` and `kn-view-back`

**Files:**
- Modify: [krillnotes-desktop/src/styles/globals.css](krillnotes-desktop/src/styles/globals.css)

**Step 1: Add styles at the end of the `kn-view-*` section**

After the last dark-mode badge override (line 119 — `.kn-view-badge-purple` dark), add:

```css

/* Note navigation link generated by link_to() */
.kn-view-link           { color: var(--color-accent); cursor: pointer;
                          text-decoration: underline; }
.kn-view-link:hover     { opacity: 0.8; }

/* Back button shown above view content when navigation history is non-empty */
.kn-view-back           { padding: 0.25rem 0; margin-bottom: 0.75rem; }
.kn-view-back button    { background: none; border: none; cursor: pointer;
                          color: var(--color-accent); font-size: 0.875rem;
                          padding: 0; }
.kn-view-back button:hover { opacity: 0.8; }
```

---

### Task 6: Build, smoke-test, and commit

**Step 1: TypeScript type-check**

```bash
cd krillnotes-desktop && npx tsc --noEmit 2>&1
```

Expected: no errors.

**Step 2: Build the frontend**

```bash
cd krillnotes-desktop && npm run build 2>&1 | tail -20
```

Expected: successful build, no errors.

**Step 3: Manual smoke-test checklist**

Open the app and verify:
- [ ] A note with an `on_view` hook can call `link_to(get_note(some_id))` in its script and the rendered HTML shows a styled, underlined link
- [ ] Clicking the link navigates to the target note
- [ ] The back button `← Back to "..."` appears above the view content of the target note (whether or not it has a custom view)
- [ ] Clicking the back button returns to the original note
- [ ] Following A → B → C via links, the back button steps back C → B → A
- [ ] Clicking a tree node clears history; back button disappears
- [ ] Back button does NOT appear in edit mode

**Step 4: Commit frontend changes**

```bash
git add krillnotes-desktop/src/components/WorkspaceView.tsx \
        krillnotes-desktop/src/components/InfoPanel.tsx \
        krillnotes-desktop/src/styles/globals.css
git commit -m "feat(ui): add link_to navigation with history stack and back button"
```

**Step 5: Mark TODO item done**

In `TODO.md`, change:

```
[ ] add the view function link_to(note) to the view commands. As part of this feature you will also need to implement a note view history and back button functionality, so that the user can go back to the original viewed note after following a link from another note.
```

to:

```
[x] add the view function link_to(note) to the view commands. As part of this feature you will also need to implement a note view history and back button functionality, so that the user can go back to the original viewed note after following a link from another note.
```

**Step 6: Final commit**

```bash
git add TODO.md
git commit -m "docs: mark link_to feature as complete in TODO"
```
