# Native Menu i18n Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Translate the Tauri native application menu using the same locale JSON files as the React frontend, with immediate menu rebuild when the user saves a language change.

**Architecture:** A `build.rs` build script scans `krillnotes-desktop/src/i18n/locales/*.json` at compile time and embeds all locale content into a generated Rust file. A new `locales.rs` module exposes `menu_strings(lang)` which parses and returns the `menu` section of the right locale (with English fallback). `build_menu` is updated to accept a `&serde_json::Value` strings parameter. `update_settings` is updated to rebuild and reapply all open window menus when the language changes.

**Tech Stack:** Rust `build.rs` (std only), `serde_json` (already in dependencies), Tauri 2 menu API (`app.set_menu`, `window.set_menu`).

**Working directory:** All work happens inside `.worktrees/feat/i18n/`.

---

### Task 1: Add `menu` block to all locale JSON files

**Files:**
- Modify: `krillnotes-desktop/src/i18n/locales/en.json`
- Modify: `krillnotes-desktop/src/i18n/locales/de.json`
- Modify: `krillnotes-desktop/src/i18n/locales/fr.json`
- Modify: `krillnotes-desktop/src/i18n/locales/es.json`
- Modify: `krillnotes-desktop/src/i18n/locales/ja.json`
- Modify: `krillnotes-desktop/src/i18n/locales/ko.json`
- Modify: `krillnotes-desktop/src/i18n/locales/zh.json`

**Step 1: Add the `menu` block to each locale JSON**

Add a top-level `"menu"` key to each file. The key must appear as a sibling of `"common"`, `"settings"`, etc. Add it before the closing `}` of the root object, following the existing JSON structure (comma after the previous last key).

**`en.json` — add before final `}`:**
```json
  "menu": {
    "file": "File",
    "edit": "Edit",
    "tools": "Tools",
    "view": "View",
    "help": "Help",
    "newWorkspace": "New Workspace",
    "openWorkspace": "Open Workspace…",
    "exportWorkspace": "Export Workspace…",
    "importWorkspace": "Import Workspace…",
    "addNote": "Add Note",
    "deleteNote": "Delete Note",
    "copyNote": "Copy Note",
    "pasteAsChild": "Paste as Child",
    "pasteAsSibling": "Paste as Sibling",
    "workspaceProperties": "Workspace Properties…",
    "settings": "Settings…",
    "manageScripts": "Manage Scripts…",
    "operationsLog": "Operations Log…",
    "refresh": "Refresh",
    "aboutKrillnotes": "About Krillnotes"
  }
```

**`de.json`:**
```json
  "menu": {
    "file": "Datei",
    "edit": "Bearbeiten",
    "tools": "Werkzeuge",
    "view": "Ansicht",
    "help": "Hilfe",
    "newWorkspace": "Neuer Arbeitsbereich",
    "openWorkspace": "Arbeitsbereich öffnen…",
    "exportWorkspace": "Arbeitsbereich exportieren…",
    "importWorkspace": "Arbeitsbereich importieren…",
    "addNote": "Notiz hinzufügen",
    "deleteNote": "Notiz löschen",
    "copyNote": "Notiz kopieren",
    "pasteAsChild": "Als Kind einfügen",
    "pasteAsSibling": "Als Geschwister einfügen",
    "workspaceProperties": "Arbeitsbereich-Eigenschaften…",
    "settings": "Einstellungen…",
    "manageScripts": "Skripte verwalten…",
    "operationsLog": "Betriebsprotokoll…",
    "refresh": "Aktualisieren",
    "aboutKrillnotes": "Über Krillnotes"
  }
```

**`fr.json`:**
```json
  "menu": {
    "file": "Fichier",
    "edit": "Édition",
    "tools": "Outils",
    "view": "Affichage",
    "help": "Aide",
    "newWorkspace": "Nouvel espace de travail",
    "openWorkspace": "Ouvrir un espace de travail…",
    "exportWorkspace": "Exporter l'espace de travail…",
    "importWorkspace": "Importer un espace de travail…",
    "addNote": "Ajouter une note",
    "deleteNote": "Supprimer la note",
    "copyNote": "Copier la note",
    "pasteAsChild": "Coller comme enfant",
    "pasteAsSibling": "Coller comme frère",
    "workspaceProperties": "Propriétés de l'espace de travail…",
    "settings": "Préférences…",
    "manageScripts": "Gérer les scripts…",
    "operationsLog": "Journal des opérations…",
    "refresh": "Actualiser",
    "aboutKrillnotes": "À propos de Krillnotes"
  }
```

**`es.json`:**
```json
  "menu": {
    "file": "Archivo",
    "edit": "Editar",
    "tools": "Herramientas",
    "view": "Ver",
    "help": "Ayuda",
    "newWorkspace": "Nuevo espacio de trabajo",
    "openWorkspace": "Abrir espacio de trabajo…",
    "exportWorkspace": "Exportar espacio de trabajo…",
    "importWorkspace": "Importar espacio de trabajo…",
    "addNote": "Añadir nota",
    "deleteNote": "Eliminar nota",
    "copyNote": "Copiar nota",
    "pasteAsChild": "Pegar como hijo",
    "pasteAsSibling": "Pegar como hermano",
    "workspaceProperties": "Propiedades del espacio de trabajo…",
    "settings": "Ajustes…",
    "manageScripts": "Gestionar scripts…",
    "operationsLog": "Registro de operaciones…",
    "refresh": "Actualizar",
    "aboutKrillnotes": "Acerca de Krillnotes"
  }
```

**`ja.json`:**
```json
  "menu": {
    "file": "ファイル",
    "edit": "編集",
    "tools": "ツール",
    "view": "表示",
    "help": "ヘルプ",
    "newWorkspace": "新しいワークスペース",
    "openWorkspace": "ワークスペースを開く…",
    "exportWorkspace": "ワークスペースを書き出す…",
    "importWorkspace": "ワークスペースを読み込む…",
    "addNote": "ノートを追加",
    "deleteNote": "ノートを削除",
    "copyNote": "ノートをコピー",
    "pasteAsChild": "子として貼り付け",
    "pasteAsSibling": "兄弟として貼り付け",
    "workspaceProperties": "ワークスペースのプロパティ…",
    "settings": "設定…",
    "manageScripts": "スクリプトを管理…",
    "operationsLog": "操作ログ…",
    "refresh": "更新",
    "aboutKrillnotes": "Krillnotesについて"
  }
```

**`ko.json`:**
```json
  "menu": {
    "file": "파일",
    "edit": "편집",
    "tools": "도구",
    "view": "보기",
    "help": "도움말",
    "newWorkspace": "새 작업 공간",
    "openWorkspace": "작업 공간 열기…",
    "exportWorkspace": "작업 공간 내보내기…",
    "importWorkspace": "작업 공간 가져오기…",
    "addNote": "노트 추가",
    "deleteNote": "노트 삭제",
    "copyNote": "노트 복사",
    "pasteAsChild": "자식으로 붙여넣기",
    "pasteAsSibling": "형제로 붙여넣기",
    "workspaceProperties": "작업 공간 속성…",
    "settings": "설정…",
    "manageScripts": "스크립트 관리…",
    "operationsLog": "작업 로그…",
    "refresh": "새로 고침",
    "aboutKrillnotes": "Krillnotes 정보"
  }
```

**`zh.json`:**
```json
  "menu": {
    "file": "文件",
    "edit": "编辑",
    "tools": "工具",
    "view": "视图",
    "help": "帮助",
    "newWorkspace": "新建工作区",
    "openWorkspace": "打开工作区…",
    "exportWorkspace": "导出工作区…",
    "importWorkspace": "导入工作区…",
    "addNote": "添加笔记",
    "deleteNote": "删除笔记",
    "copyNote": "复制笔记",
    "pasteAsChild": "粘贴为子节点",
    "pasteAsSibling": "粘贴为兄弟节点",
    "workspaceProperties": "工作区属性…",
    "settings": "设置…",
    "manageScripts": "管理脚本…",
    "operationsLog": "操作日志…",
    "refresh": "刷新",
    "aboutKrillnotes": "关于 Krillnotes"
  }
```

**Step 2: Validate JSON syntax**

Run from `krillnotes-desktop/src/i18n/locales/`:
```bash
for f in *.json; do python3 -m json.tool "$f" > /dev/null && echo "$f OK" || echo "$f INVALID"; done
```
Expected: all files print `OK`.

**Step 3: Commit**
```bash
git add krillnotes-desktop/src/i18n/locales/
git commit -m "feat: add menu translation keys to all locale JSON files"
```

---

### Task 2: Update `build.rs` to embed locale JSON content

**Files:**
- Modify: `krillnotes-desktop/src-tauri/build.rs`

The build script reads every `*.json` file from the locales directory at compile time and embeds the raw JSON as escaped string literals in a generated Rust file (`$OUT_DIR/locales_generated.rs`). No new Cargo dependencies are needed — this uses only `std::fs` and `std::env`.

**Step 1: Rewrite `build.rs`**

Replace the entire contents of `krillnotes-desktop/src-tauri/build.rs`:

```rust
//! Tauri build script.
//!
//! 1. Runs Tauri's required code-generation step.
//! 2. Scans `../src/i18n/locales/*.json` and generates `$OUT_DIR/locales_generated.rs`,
//!    which embeds all locale JSON content as static string literals. Adding a new
//!    language requires only dropping a JSON file in the locales directory.

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    tauri_build::build();

    let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set");
    let locales_dir = Path::new(&manifest_dir).join("../src/i18n/locales");
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let out_path = Path::new(&out_dir).join("locales_generated.rs");

    // Re-run this script if the locales directory itself changes (new file added/removed).
    println!("cargo:rerun-if-changed=../src/i18n/locales");

    let mut entries: Vec<(String, String)> = Vec::new();

    if let Ok(read_dir) = fs::read_dir(&locales_dir) {
        for entry in read_dir.flatten() {
            let path = entry.path();
            if path.extension().and_then(|e| e.to_str()) == Some("json") {
                if let Some(lang) = path.file_stem().and_then(|s| s.to_str()) {
                    // Re-run if this specific file changes.
                    println!("cargo:rerun-if-changed={}", path.display());
                    let content = fs::read_to_string(&path)
                        .unwrap_or_else(|_| "{}".to_string());
                    entries.push((lang.to_string(), content));
                }
            }
        }
    }

    // Sort for deterministic output.
    entries.sort_by(|a, b| a.0.cmp(&b.0));

    let mut code = String::from("// Auto-generated by build.rs \u{2014} do not edit.\n");
    code.push_str("pub static LOCALES: &[(&str, &str)] = &[\n");
    for (lang, content) in &entries {
        // Escape the JSON content for embedding as a Rust string literal.
        let escaped = content
            .replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n")
            .replace('\r', "");
        code.push_str(&format!("    (\"{lang}\", \"{escaped}\"),\n"));
    }
    code.push_str("];\n");

    fs::write(&out_path, &code).expect("Failed to write locales_generated.rs");
}
```

**Step 2: Verify the build compiles**

Run from `krillnotes-desktop/src-tauri/`:
```bash
cargo build 2>&1 | head -20
```
Expected: compiles successfully. You can also check the generated file exists:
```bash
ls target/debug/build/krillnotes-desktop-*/out/locales_generated.rs
```

**Step 3: Commit**
```bash
git add krillnotes-desktop/src-tauri/build.rs
git commit -m "feat: build.rs generates embedded locale data from JSON files"
```

---

### Task 3: Create `src/locales.rs` with `menu_strings()` and unit tests

**Files:**
- Create: `krillnotes-desktop/src-tauri/src/locales.rs`
- Modify: `krillnotes-desktop/src-tauri/src/lib.rs` (add `pub mod locales;`)

**Step 1: Write the failing tests first**

Create `krillnotes-desktop/src-tauri/src/locales.rs` with only the tests (no implementation yet):

```rust
//! Embedded locale data for the native application menu.
//!
//! `LOCALES` is generated at compile time by `build.rs` from all JSON files in
//! `krillnotes-desktop/src/i18n/locales/`. To add a new language, create a
//! JSON file there — no Rust changes are needed.

include!(concat!(env!("OUT_DIR"), "/locales_generated.rs"));

use serde_json::Value;

pub fn menu_strings(_lang: &str) -> Value {
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn english_has_expected_menu_keys() {
        let s = menu_strings("en");
        assert_eq!(s["file"].as_str(), Some("File"));
        assert_eq!(s["edit"].as_str(), Some("Edit"));
        assert_eq!(s["newWorkspace"].as_str(), Some("New Workspace"));
        assert_eq!(s["refresh"].as_str(), Some("Refresh"));
    }

    #[test]
    fn german_menu_is_translated() {
        let s = menu_strings("de");
        assert_eq!(s["file"].as_str(), Some("Datei"));
        assert_eq!(s["edit"].as_str(), Some("Bearbeiten"));
        assert_eq!(s["newWorkspace"].as_str(), Some("Neuer Arbeitsbereich"));
    }

    #[test]
    fn unknown_language_falls_back_to_english() {
        let s = menu_strings("xx");
        assert_eq!(s["file"].as_str(), Some("File"));
        assert_eq!(s["newWorkspace"].as_str(), Some("New Workspace"));
    }
}
```

Add `pub mod locales;` to `lib.rs` alongside the existing module declarations (around line 7):
```rust
pub mod locales;
pub mod menu;
pub mod settings;
pub mod themes;
```

**Step 2: Run tests to verify they fail**

```bash
cd krillnotes-desktop/src-tauri && cargo test locales 2>&1 | tail -10
```
Expected: 3 tests fail with `not yet implemented` (todo! panic).

**Step 3: Implement `menu_strings`**

Replace the `todo!()` stub in `locales.rs` with the real implementation:

```rust
/// Returns the `menu` section of the locale for `lang`, merging over the
/// English base so that partially-translated locales always have all keys.
/// Falls back to English entirely if `lang` is not found.
pub fn menu_strings(lang: &str) -> Value {
    let en_menu = parse_menu("en").unwrap_or_else(|| Value::Object(Default::default()));

    if lang == "en" {
        return en_menu;
    }

    let Some(target_menu) = parse_menu(lang) else {
        return en_menu;
    };

    // Merge: start with English, overlay translated keys.
    let mut result = en_menu;
    if let (Value::Object(ref mut base), Value::Object(target)) = (&mut result, target_menu) {
        for (k, v) in target {
            base.insert(k, v);
        }
    }
    result
}

fn parse_menu(lang: &str) -> Option<Value> {
    let json_str = LOCALES.iter().find(|(l, _)| *l == lang).map(|(_, s)| *s)?;
    let root: Value = serde_json::from_str(json_str).ok()?;
    root.get("menu").cloned()
}
```

**Step 4: Run tests to verify they pass**

```bash
cargo test locales 2>&1 | tail -10
```
Expected:
```
test locales::tests::english_has_expected_menu_keys ... ok
test locales::tests::german_menu_is_translated ... ok
test locales::tests::unknown_language_falls_back_to_english ... ok

test result: ok. 3 passed; 0 failed
```

**Step 5: Run full test suite**

```bash
cargo test 2>&1 | tail -5
```
Expected: all tests pass (242+ tests).

**Step 6: Commit**
```bash
git add krillnotes-desktop/src-tauri/src/locales.rs krillnotes-desktop/src-tauri/src/lib.rs
git commit -m "feat: locales module with menu_strings() and English fallback"
```

---

### Task 4: Update `menu.rs` to use translated strings

**Files:**
- Modify: `krillnotes-desktop/src-tauri/src/menu.rs`

All five build functions receive a `strings: &serde_json::Value` parameter and use it instead of hardcoded string literals. The English fallback strings match the existing hardcoded values exactly, so the menu is always fully functional even if a key is somehow missing.

**Step 1: Update all function signatures and string usages**

Replace the entire contents of `menu.rs`:

```rust
//! Application menu construction for Krillnotes.

use serde_json::Value;
use tauri::{menu::*, AppHandle, Runtime};

/// Return type of [`build_menu`].
pub struct MenuResult<R: Runtime> {
    pub menu: Menu<R>,
    pub paste_as_child: MenuItem<R>,
    pub paste_as_sibling: MenuItem<R>,
    pub workspace_items: Vec<MenuItem<R>>,
}

struct EditMenuResult<R: Runtime> {
    submenu: Submenu<R>,
    paste_as_child: MenuItem<R>,
    paste_as_sibling: MenuItem<R>,
    workspace_items: Vec<MenuItem<R>>,
}

struct FileMenuResult<R: Runtime> {
    submenu: Submenu<R>,
    workspace_items: Vec<MenuItem<R>>,
}

struct ToolsMenuResult<R: Runtime> {
    submenu: Submenu<R>,
    workspace_items: Vec<MenuItem<R>>,
}

/// Builds the application menu with labels from `strings` (the `menu` section
/// of a locale JSON, as returned by [`crate::locales::menu_strings`]).
///
/// On macOS: App menu (Krillnotes), File, Edit, Tools, View.
/// On other platforms: File, Edit, Tools, View, Help.
pub fn build_menu<R: Runtime>(app: &AppHandle<R>, strings: &Value) -> Result<MenuResult<R>, tauri::Error> {
    let file_result = build_file_menu(app, strings)?;
    let edit_result = build_edit_menu(app, strings)?;
    let tools_result = build_tools_menu(app, strings)?;
    let view_menu = build_view_menu(app, strings)?;

    let mut workspace_items = Vec::new();
    workspace_items.extend(file_result.workspace_items);
    workspace_items.extend(edit_result.workspace_items);
    workspace_items.extend(tools_result.workspace_items);

    #[cfg(target_os = "macos")]
    {
        let app_menu = build_macos_app_menu(app, strings)?;
        let menu = MenuBuilder::new(app)
            .items(&[&app_menu, &file_result.submenu, &edit_result.submenu, &tools_result.submenu, &view_menu])
            .build()?;
        return Ok(MenuResult {
            menu,
            paste_as_child: edit_result.paste_as_child,
            paste_as_sibling: edit_result.paste_as_sibling,
            workspace_items,
        });
    }

    #[cfg(not(target_os = "macos"))]
    {
        let help_menu = build_help_menu(app, strings)?;
        let menu = MenuBuilder::new(app)
            .items(&[&file_result.submenu, &edit_result.submenu, &tools_result.submenu, &view_menu, &help_menu])
            .build()?;
        return Ok(MenuResult {
            menu,
            paste_as_child: edit_result.paste_as_child,
            paste_as_sibling: edit_result.paste_as_sibling,
            workspace_items,
        });
    }
}

fn s<'a>(strings: &'a Value, key: &str, fallback: &'a str) -> &'a str {
    strings[key].as_str().unwrap_or(fallback)
}

fn build_view_menu<R: Runtime>(app: &AppHandle<R>, strings: &Value) -> Result<Submenu<R>, tauri::Error> {
    SubmenuBuilder::new(app, s(strings, "view", "View"))
        .items(&[
            &PredefinedMenuItem::fullscreen(app, None)?,
            &PredefinedMenuItem::separator(app)?,
            &MenuItemBuilder::with_id("view_refresh", s(strings, "refresh", "Refresh"))
                .accelerator("CmdOrCtrl+R")
                .build(app)?,
        ])
        .build()
}

fn build_tools_menu<R: Runtime>(app: &AppHandle<R>, strings: &Value) -> Result<ToolsMenuResult<R>, tauri::Error> {
    let manage_scripts = MenuItemBuilder::with_id("edit_manage_scripts", s(strings, "manageScripts", "Manage Scripts..."))
        .enabled(false)
        .build(app)?;
    let operations_log = MenuItemBuilder::with_id("view_operations_log", s(strings, "operationsLog", "Operations Log..."))
        .enabled(false)
        .build(app)?;

    let submenu = SubmenuBuilder::new(app, s(strings, "tools", "Tools"))
        .items(&[&manage_scripts, &operations_log])
        .build()?;

    Ok(ToolsMenuResult {
        submenu,
        workspace_items: vec![manage_scripts, operations_log],
    })
}

fn build_file_menu<R: Runtime>(app: &AppHandle<R>, strings: &Value) -> Result<FileMenuResult<R>, tauri::Error> {
    let new_item = MenuItemBuilder::with_id("file_new", s(strings, "newWorkspace", "New Workspace"))
        .accelerator("CmdOrCtrl+N")
        .build(app)?;
    let open_item = MenuItemBuilder::with_id("file_open", s(strings, "openWorkspace", "Open Workspace..."))
        .accelerator("CmdOrCtrl+O")
        .build(app)?;
    let sep1 = PredefinedMenuItem::separator(app)?;
    let export_item = MenuItemBuilder::with_id("file_export", s(strings, "exportWorkspace", "Export Workspace..."))
        .enabled(false)
        .build(app)?;
    let import_item = MenuItemBuilder::with_id("file_import", s(strings, "importWorkspace", "Import Workspace..."))
        .build(app)?;
    let sep2 = PredefinedMenuItem::separator(app)?;
    let close_item = PredefinedMenuItem::close_window(app, None)?;

    let builder = SubmenuBuilder::new(app, s(strings, "file", "File"))
        .items(&[&new_item, &open_item, &sep1, &export_item, &import_item, &sep2, &close_item]);

    #[cfg(not(target_os = "macos"))]
    let builder = {
        let quit_item = PredefinedMenuItem::quit(app, None)?;
        builder.item(&quit_item)
    };

    let submenu = builder.build()?;
    Ok(FileMenuResult {
        submenu,
        workspace_items: vec![export_item],
    })
}

fn build_edit_menu<R: Runtime>(app: &AppHandle<R>, strings: &Value) -> Result<EditMenuResult<R>, tauri::Error> {
    let add_note = MenuItemBuilder::with_id("edit_add_note", s(strings, "addNote", "Add Note"))
        .accelerator("CmdOrCtrl+Shift+N")
        .enabled(false)
        .build(app)?;
    let delete_note = MenuItemBuilder::with_id("edit_delete_note", s(strings, "deleteNote", "Delete Note"))
        .accelerator("CmdOrCtrl+Backspace")
        .enabled(false)
        .build(app)?;
    let sep1 = PredefinedMenuItem::separator(app)?;
    let copy_note = MenuItemBuilder::with_id("edit_copy_note", s(strings, "copyNote", "Copy Note"))
        .enabled(false)
        .build(app)?;
    let paste_child = MenuItemBuilder::with_id("edit_paste_as_child", s(strings, "pasteAsChild", "Paste as Child"))
        .enabled(false)
        .build(app)?;
    let paste_sibling = MenuItemBuilder::with_id("edit_paste_as_sibling", s(strings, "pasteAsSibling", "Paste as Sibling"))
        .enabled(false)
        .build(app)?;
    let sep2 = PredefinedMenuItem::separator(app)?;
    let workspace_properties = MenuItemBuilder::with_id("workspace_properties", s(strings, "workspaceProperties", "Workspace Properties\u{2026}"))
        .enabled(false)
        .build(app)?;
    let sep3 = PredefinedMenuItem::separator(app)?;
    let undo = PredefinedMenuItem::undo(app, None)?;
    let redo = PredefinedMenuItem::redo(app, None)?;
    let copy = PredefinedMenuItem::copy(app, None)?;
    let paste = PredefinedMenuItem::paste(app, None)?;

    let builder = SubmenuBuilder::new(app, s(strings, "edit", "Edit"))
        .items(&[&add_note, &delete_note, &sep1, &copy_note, &paste_child, &paste_sibling,
                 &sep2, &workspace_properties, &sep3]);

    #[cfg(not(target_os = "macos"))]
    let builder = {
        let settings = MenuItemBuilder::with_id("edit_settings", s(strings, "settings", "Settings..."))
            .accelerator("CmdOrCtrl+,")
            .build(app)?;
        let sep4 = PredefinedMenuItem::separator(app)?;
        builder.item(&settings).item(&sep4)
    };

    let submenu = builder.items(&[&undo, &redo, &copy, &paste]).build()?;
    Ok(EditMenuResult {
        submenu,
        paste_as_child: paste_child,
        paste_as_sibling: paste_sibling,
        workspace_items: vec![add_note, delete_note, copy_note, workspace_properties],
    })
}

#[cfg(target_os = "macos")]
fn build_macos_app_menu<R: Runtime>(app: &AppHandle<R>, strings: &Value) -> Result<Submenu<R>, tauri::Error> {
    SubmenuBuilder::new(app, "Krillnotes")
        .items(&[
            &PredefinedMenuItem::about(app, None, None)?,
            &PredefinedMenuItem::separator(app)?,
            &MenuItemBuilder::with_id("edit_settings", s(strings, "settings", "Settings..."))
                .accelerator("CmdOrCtrl+,")
                .build(app)?,
            &PredefinedMenuItem::separator(app)?,
            &PredefinedMenuItem::services(app, None)?,
            &PredefinedMenuItem::separator(app)?,
            &PredefinedMenuItem::hide(app, None)?,
            &PredefinedMenuItem::hide_others(app, None)?,
            &PredefinedMenuItem::show_all(app, None)?,
            &PredefinedMenuItem::separator(app)?,
            &PredefinedMenuItem::quit(app, None)?,
        ])
        .build()
}

#[cfg(not(target_os = "macos"))]
fn build_help_menu<R: Runtime>(app: &AppHandle<R>, strings: &Value) -> Result<Submenu<R>, tauri::Error> {
    SubmenuBuilder::new(app, s(strings, "help", "Help"))
        .items(&[
            &MenuItemBuilder::with_id("help_about", s(strings, "aboutKrillnotes", "About Krillnotes"))
                .build(app)?,
        ])
        .build()
}
```

**Step 2: Verify it compiles**

```bash
cargo build 2>&1 | grep -E "error|warning" | head -20
```
Expected: no errors. There may be warnings about unused imports from the old code — none expected with this full rewrite.

**Step 3: Run all tests**

```bash
cargo test 2>&1 | tail -5
```
Expected: all tests pass.

**Step 4: Commit**
```bash
git add krillnotes-desktop/src-tauri/src/menu.rs
git commit -m "feat: menu.rs accepts locale strings instead of hardcoded English"
```

---

### Task 5: Wire language into startup and workspace window creation

**Files:**
- Modify: `krillnotes-desktop/src-tauri/src/lib.rs`

Two call sites currently call `menu::build_menu(app)` or `menu::build_menu(app.handle())`. Both need to load the current language and pass `locales::menu_strings(&lang)`.

**Step 1: Update `setup()` (around line 1393)**

Find this block in `lib.rs`:
```rust
.setup(|app| {
    let menu_result = menu::build_menu(app.handle())?;
    app.set_menu(menu_result.menu)?;
```

Replace with:
```rust
.setup(|app| {
    let lang = settings::load_settings().language;
    let strings = locales::menu_strings(&lang);
    let menu_result = menu::build_menu(app.handle(), &strings)?;
    app.set_menu(menu_result.menu)?;
```

**Step 2: Update `create_workspace_window()` (around line 127)**

Find:
```rust
    let menu_result = menu::build_menu(app)
        .map_err(|e| format!("Failed to build menu: {e}"))?;
```

Replace with:
```rust
    let lang = settings::load_settings().language;
    let strings = locales::menu_strings(&lang);
    let menu_result = menu::build_menu(app, &strings)
        .map_err(|e| format!("Failed to build menu: {e}"))?;
```

**Step 3: Verify compilation**

```bash
cargo build 2>&1 | grep error
```
Expected: no errors.

**Step 4: Run all tests**

```bash
cargo test 2>&1 | tail -5
```
Expected: all tests pass.

**Step 5: Commit**
```bash
git add krillnotes-desktop/src-tauri/src/lib.rs
git commit -m "feat: menu uses saved language at startup and workspace window creation"
```

---

### Task 6: Add `rebuild_menus` + update `update_settings` to rebuild on language change

**Files:**
- Modify: `krillnotes-desktop/src-tauri/src/lib.rs`

**Step 1: Add `rebuild_menus` helper**

Add this function in `lib.rs` near `create_workspace_window` (it's a similar helper):

```rust
/// Rebuilds and reapplies the native menu for all open windows using `lang`.
///
/// On macOS the menu bar is global: one menu is set on the app and the stored
/// paste/workspace handles in AppState are updated.
/// On Windows each window owns its own menu: every open window gets a freshly
/// built menu, with workspace items pre-enabled for workspace windows.
fn rebuild_menus(app: &AppHandle, state: &AppState, lang: &str) -> std::result::Result<(), String> {
    let strings = locales::menu_strings(lang);

    #[cfg(target_os = "macos")]
    {
        let result = menu::build_menu(app, &strings)
            .map_err(|e| format!("Failed to build menu: {e}"))?;
        app.set_menu(result.menu)
            .map_err(|e| format!("Failed to set menu: {e}"))?;
        state.paste_menu_items.lock().expect("Mutex poisoned")
            .insert("macos".to_string(), (result.paste_as_child, result.paste_as_sibling));
        state.workspace_menu_items.lock().expect("Mutex poisoned")
            .insert("macos".to_string(), result.workspace_items);
    }

    #[cfg(not(target_os = "macos"))]
    {
        // Collect workspace labels first to avoid holding the lock while calling Tauri APIs.
        let ws_labels: std::collections::HashSet<String> = state
            .workspace_paths
            .lock()
            .expect("Mutex poisoned")
            .keys()
            .cloned()
            .collect();

        for (label, window) in app.webview_windows() {
            let result = menu::build_menu(app, &strings)
                .map_err(|e| format!("Failed to build menu: {e}"))?;

            if ws_labels.contains(&label) {
                for item in &result.workspace_items {
                    item.set_enabled(true)
                        .map_err(|e| format!("Failed to enable menu item: {e}"))?;
                }
            }

            window
                .set_menu(result.menu)
                .map_err(|e| format!("Failed to set window menu: {e}"))?;

            state.paste_menu_items.lock().expect("Mutex poisoned")
                .insert(label.clone(), (result.paste_as_child, result.paste_as_sibling));
            state.workspace_menu_items.lock().expect("Mutex poisoned")
                .insert(label, result.workspace_items);
        }
    }

    Ok(())
}
```

**Step 2: Update `update_settings` to accept `AppHandle` + `State<AppState>` and call `rebuild_menus`**

Find the current `update_settings` function (around line 1207):
```rust
fn update_settings(patch: serde_json::Value) -> std::result::Result<(), String> {
    let current = settings::load_settings();
    let mut current_value = serde_json::to_value(&current)
        .map_err(|e| format!("Failed to serialize settings: {e}"))?;
    if let (serde_json::Value::Object(curr), serde_json::Value::Object(p)) =
        (&mut current_value, patch)
    {
        for (k, v) in p {
            curr.insert(k, v);
        }
    }
    let updated: settings::AppSettings = serde_json::from_value(current_value)
        .map_err(|e| format!("Failed to deserialize merged settings: {e}"))?;
    settings::save_settings(&updated)
}
```

Replace with:
```rust
fn update_settings(
    app: AppHandle,
    state: State<AppState>,
    patch: serde_json::Value,
) -> std::result::Result<(), String> {
    let current = settings::load_settings();
    let old_lang = current.language.clone();

    let mut current_value = serde_json::to_value(&current)
        .map_err(|e| format!("Failed to serialize settings: {e}"))?;
    if let (serde_json::Value::Object(curr), serde_json::Value::Object(p)) =
        (&mut current_value, patch)
    {
        for (k, v) in p {
            curr.insert(k, v);
        }
    }
    let updated: settings::AppSettings = serde_json::from_value(current_value)
        .map_err(|e| format!("Failed to deserialize merged settings: {e}"))?;
    settings::save_settings(&updated)?;

    if updated.language != old_lang {
        rebuild_menus(&app, &state, &updated.language)?;
    }

    Ok(())
}
```

**Step 3: Verify compilation**

```bash
cargo build 2>&1 | grep error
```
Expected: no errors. Tauri automatically injects `AppHandle` and `State<T>` parameters in commands — no changes to the command registration in `generate_handler!` are needed.

**Step 4: Run all tests**

```bash
cargo test 2>&1 | tail -5
```
Expected: all tests pass.

**Step 5: Manual smoke test**

Run the app (`cargo tauri dev` from `krillnotes-desktop/`), open Settings, switch to a non-English language, press Save, and verify the native menu bar labels change immediately without restarting the app.

**Step 6: Commit**
```bash
git add krillnotes-desktop/src-tauri/src/lib.rs
git commit -m "feat: rebuild native menu immediately when language changes in settings"
```

---

### Task 7: TypeScript build check and push

**Step 1: Run TypeScript type-check**

```bash
cd krillnotes-desktop && npx tsc --noEmit
```
Expected: no errors (this task only touched Rust, but good to confirm the frontend is still clean).

**Step 2: Run full Rust test suite one final time**

```bash
cd src-tauri && cargo test 2>&1 | tail -5
```
Expected: all tests pass.

**Step 3: Push to update PR**

```bash
git push github-https feat/i18n
```
