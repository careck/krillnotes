# Tags Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add first-class tags to notes â€” a `note_tags` junction table, full CRUD API, tag pill UI in the editor and default view, scripting helpers, a tag cloud panel in the tree, and workspace export support.

**Architecture:** Tags live in a `note_tags(note_id, tag)` junction table with ON DELETE CASCADE. The `Note` struct gains a `tags: Vec<String>` field populated via a LEFT JOIN + GROUP_CONCAT in every note query. All nine issue requirements are covered in one feature branch.

**Tech Stack:** Rust / SQLite / rusqlite, Rhai scripting, Tauri v2, React + TypeScript, CSS custom properties.

**Design doc:** `docs/plans/2026-02-26-tags-design.md`

---

## Task 1: Create feature worktree

**Step 1: Create the worktree and branch**

```bash
git -C /Users/careck/Source/Krillnotes worktree add .worktrees/feat/tags -b feat/tags
```

All subsequent work happens inside `/Users/careck/Source/Krillnotes/.worktrees/feat/tags/`.

**Step 2: Verify**

```bash
cd /Users/careck/Source/Krillnotes/.worktrees/feat/tags && git branch
```

Expected: `* feat/tags`

---

## Task 2: Database â€” add `note_tags` table + migration

**Files:**
- Modify: `krillnotes-core/src/core/schema.sql`
- Modify: `krillnotes-core/src/core/storage.rs` (in `run_migrations`)

**Step 1: Add table to schema.sql**

Append to the end of `krillnotes-core/src/core/schema.sql`:

```sql
-- Note tags (first-class, not schema-defined)
CREATE TABLE IF NOT EXISTS note_tags (
    note_id TEXT NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
    tag     TEXT NOT NULL,
    PRIMARY KEY (note_id, tag)
);
CREATE INDEX IF NOT EXISTS idx_note_tags_tag ON note_tags(tag);
```

**Step 2: Add migration in `storage.rs`**

In `run_migrations`, after the `user_scripts` block, add:

```rust
// Migration: add note_tags table if absent.
let note_tags_exists: bool = conn.query_row(
    "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='note_tags'",
    [],
    |row| row.get::<_, i64>(0).map(|c| c > 0),
)?;
if !note_tags_exists {
    conn.execute_batch(
        "CREATE TABLE IF NOT EXISTS note_tags (
            note_id TEXT NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
            tag     TEXT NOT NULL,
            PRIMARY KEY (note_id, tag)
        );
        CREATE INDEX IF NOT EXISTS idx_note_tags_tag ON note_tags(tag);"
    )?;
}
```

**Step 3: Write failing test**

In `krillnotes-core/src/core/storage.rs` tests, add:

```rust
#[test]
fn test_note_tags_table_created_on_new_workspace() {
    let temp = NamedTempFile::new().unwrap();
    let storage = Storage::create(temp.path(), "").unwrap();
    let count: i64 = storage.connection().query_row(
        "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='note_tags'",
        [],
        |row| row.get(0),
    ).unwrap();
    assert_eq!(count, 1);
}

#[test]
fn test_note_tags_table_migration_on_existing_workspace() {
    // Simulate an old workspace that has no note_tags table.
    let temp = NamedTempFile::new().unwrap();
    // Create raw DB without note_tags
    {
        let conn = Connection::open(temp.path()).unwrap();
        conn.execute_batch(
            "CREATE TABLE notes (id TEXT PRIMARY KEY, title TEXT NOT NULL,
             node_type TEXT NOT NULL, parent_id TEXT, position INTEGER NOT NULL,
             created_at INTEGER NOT NULL, modified_at INTEGER NOT NULL,
             created_by INTEGER NOT NULL DEFAULT 0, modified_by INTEGER NOT NULL DEFAULT 0,
             fields_json TEXT NOT NULL DEFAULT '{}', is_expanded INTEGER DEFAULT 1);
             CREATE TABLE operations (id INTEGER PRIMARY KEY AUTOINCREMENT,
             operation_id TEXT UNIQUE NOT NULL, timestamp INTEGER NOT NULL,
             device_id TEXT NOT NULL, operation_type TEXT NOT NULL,
             operation_data TEXT NOT NULL, synced INTEGER DEFAULT 0);
             CREATE TABLE workspace_meta (key TEXT PRIMARY KEY, value TEXT NOT NULL);
             CREATE TABLE user_scripts (id TEXT PRIMARY KEY, name TEXT NOT NULL DEFAULT '',
             description TEXT NOT NULL DEFAULT '', source_code TEXT NOT NULL,
             load_order INTEGER NOT NULL DEFAULT 0, enabled INTEGER NOT NULL DEFAULT 1,
             created_at INTEGER NOT NULL, modified_at INTEGER NOT NULL);"
        ).unwrap();
    }
    // Open via Storage â€” should run migration
    let storage = Storage::open(temp.path(), "").unwrap();
    let count: i64 = storage.connection().query_row(
        "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='note_tags'",
        [],
        |row| row.get(0),
    ).unwrap();
    assert_eq!(count, 1);
}
```

**Step 4: Run test to verify it fails**

```bash
cargo test -p krillnotes-core test_note_tags_table -- --nocapture
```

Expected: FAIL â€” table doesn't exist yet.

**Step 5: Apply schema and migration changes** (Steps 1 and 2 above)

**Step 6: Run tests to verify they pass**

```bash
cargo test -p krillnotes-core test_note_tags_table -- --nocapture
```

Expected: PASS

**Step 7: Commit**

```bash
git add krillnotes-core/src/core/schema.sql krillnotes-core/src/core/storage.rs
git commit -m "feat(tags): add note_tags junction table and migration"
```

---

## Task 3: Add `tags` field to the `Note` struct

**Files:**
- Modify: `krillnotes-core/src/core/note.rs`

**Step 1: Add field to struct**

In `note.rs`, add `tags` after `is_expanded`:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Note {
    pub id: String,
    pub title: String,
    pub node_type: String,
    pub parent_id: Option<String>,
    pub position: i32,
    pub created_at: i64,
    pub modified_at: i64,
    pub created_by: i64,
    pub modified_by: i64,
    pub fields: HashMap<String, FieldValue>,
    pub is_expanded: bool,
    pub tags: Vec<String>,   // new â€” sorted, lowercase
}
```

**Step 2: Fix the test constructor in `note.rs`**

The existing `test_create_note` constructs `Note` directly. Add `tags: vec![]` to it:

```rust
let note = Note {
    // ...existing fields...
    is_expanded: true,
    tags: vec![],
};
```

**Step 3: Run tests**

```bash
cargo test -p krillnotes-core -- --nocapture
```

Expected: PASS (the struct change breaks only tests that construct `Note` directly).

**Step 4: Commit**

```bash
git add krillnotes-core/src/core/note.rs
git commit -m "feat(tags): add tags field to Note struct"
```

---

## Task 4: Update all note queries to load tags

**Files:**
- Modify: `krillnotes-core/src/core/workspace.rs`

Every function that reads notes from the DB must join `note_tags`. The current pattern is:

```rust
"SELECT id, title, node_type, parent_id, position,
        created_at, modified_at, created_by, modified_by,
        fields_json, is_expanded
 FROM notes WHERE id = ?"
```

This changes to a GROUP BY query with GROUP_CONCAT. There are three affected query sites: `get_note`, `list_all_notes`, `get_children`. Update the type alias `NoteRow` and helpers at the bottom of the file.

**Step 1: Update `NoteRow` type alias**

Find `NoteRow` type alias near the bottom of `workspace.rs`. Change the tuple to add a 12th element for the tags CSV:

```rust
type NoteRow = (
    String,          // id
    String,          // title
    String,          // node_type
    Option<String>,  // parent_id
    i64,             // position
    i64,             // created_at
    i64,             // modified_at
    i64,             // created_by
    i64,             // modified_by
    String,          // fields_json
    i64,             // is_expanded
    Option<String>,  // tags_csv (new)
);
```

**Step 2: Update `map_note_row`**

```rust
fn map_note_row(row: &rusqlite::Row) -> rusqlite::Result<NoteRow> {
    Ok((
        row.get::<_, String>(0)?,
        row.get::<_, String>(1)?,
        row.get::<_, String>(2)?,
        row.get::<_, Option<String>>(3)?,
        row.get::<_, i64>(4)?,
        row.get::<_, i64>(5)?,
        row.get::<_, i64>(6)?,
        row.get::<_, i64>(7)?,
        row.get::<_, i64>(8)?,
        row.get::<_, String>(9)?,
        row.get::<_, i64>(10)?,
        row.get::<_, Option<String>>(11)?,  // new
    ))
}
```

**Step 3: Update `note_from_row_tuple`**

```rust
fn note_from_row_tuple(
    (id, title, node_type, parent_id, position, created_at, modified_at,
     created_by, modified_by, fields_json, is_expanded_int, tags_csv): NoteRow,
) -> Result<Note> {
    let mut tags: Vec<String> = tags_csv
        .unwrap_or_default()
        .split(',')
        .filter(|s| !s.is_empty())
        .map(|s| s.to_string())
        .collect();
    tags.sort();
    Ok(Note {
        id,
        title,
        node_type,
        parent_id,
        position: position as i32,
        created_at,
        modified_at,
        created_by,
        modified_by,
        fields: serde_json::from_str(&fields_json)?,
        is_expanded: is_expanded_int == 1,
        tags,
    })
}
```

**Step 4: Update the three query sites**

Replace each SELECT in `get_note`, `list_all_notes`, and `get_children` with the joining form:

For `get_note`:
```sql
SELECT n.id, n.title, n.node_type, n.parent_id, n.position,
       n.created_at, n.modified_at, n.created_by, n.modified_by,
       n.fields_json, n.is_expanded,
       GROUP_CONCAT(nt.tag, ',') AS tags_csv
FROM notes n
LEFT JOIN note_tags nt ON nt.note_id = n.id
WHERE n.id = ?
GROUP BY n.id
```

For `list_all_notes`:
```sql
SELECT n.id, n.title, n.node_type, n.parent_id, n.position,
       n.created_at, n.modified_at, n.created_by, n.modified_by,
       n.fields_json, n.is_expanded,
       GROUP_CONCAT(nt.tag, ',') AS tags_csv
FROM notes n
LEFT JOIN note_tags nt ON nt.note_id = n.id
GROUP BY n.id
ORDER BY n.parent_id, n.position
```

For `get_children`:
```sql
SELECT n.id, n.title, n.node_type, n.parent_id, n.position,
       n.created_at, n.modified_at, n.created_by, n.modified_by,
       n.fields_json, n.is_expanded,
       GROUP_CONCAT(nt.tag, ',') AS tags_csv
FROM notes n
LEFT JOIN note_tags nt ON nt.note_id = n.id
WHERE n.parent_id = ?
GROUP BY n.id
ORDER BY n.position
```

**Step 5: Update `note_to_rhai_dynamic`** (also in `workspace.rs`)

Add tags to the Rhai map so scripting hooks can access them:

```rust
fn note_to_rhai_dynamic(note: &Note) -> Dynamic {
    use crate::core::scripting::field_value_to_dynamic;
    let mut fields_map = rhai::Map::new();
    for (k, v) in &note.fields {
        fields_map.insert(k.as_str().into(), field_value_to_dynamic(v));
    }
    // Tags as a Rhai Array of strings
    let tags_array: rhai::Array = note.tags.iter()
        .map(|t| Dynamic::from(t.clone()))
        .collect();
    let mut note_map = rhai::Map::new();
    note_map.insert("id".into(), Dynamic::from(note.id.clone()));
    note_map.insert("node_type".into(), Dynamic::from(note.node_type.clone()));
    note_map.insert("title".into(), Dynamic::from(note.title.clone()));
    note_map.insert("fields".into(), Dynamic::from(fields_map));
    note_map.insert("tags".into(), Dynamic::from(tags_array));
    Dynamic::from(note_map)
}
```

**Step 6: Write failing test**

```rust
#[test]
fn test_note_tags_round_trip() {
    let temp = NamedTempFile::new().unwrap();
    let mut ws = Workspace::create(temp.path(), "").unwrap();
    let root = ws.list_all_notes().unwrap()[0].clone();
    assert!(root.tags.is_empty());

    ws.update_note_tags(&root.id, vec!["rust".into(), "design".into()]).unwrap();
    let note = ws.get_note(&root.id).unwrap();
    assert_eq!(note.tags, vec!["design", "rust"]); // sorted
}
```

**Step 7: Run test (it will fail â€” `update_note_tags` doesn't exist yet)**

```bash
cargo test -p krillnotes-core test_note_tags_round_trip -- --nocapture
```

Expected: compile error â€” `update_note_tags` not found.

**Step 8: Run all existing tests to confirm no regressions from query changes**

```bash
cargo test -p krillnotes-core -- --nocapture
```

Expected: all pass except the new test.

**Step 9: Commit**

```bash
git add krillnotes-core/src/core/workspace.rs
git commit -m "feat(tags): join note_tags in all note queries, populate tags field"
```

---

## Task 5: Add workspace tag CRUD methods

**Files:**
- Modify: `krillnotes-core/src/core/workspace.rs`

**Step 1: Add `update_note_tags`**

Find a logical location near `update_note_title`. Add:

```rust
/// Replaces all tags for `note_id` with the provided list.
///
/// Tags are normalised (lowercased, trimmed, deduplicated) before storage.
/// Deletes existing tags and re-inserts in a single transaction.
pub fn update_note_tags(&mut self, note_id: &str, tags: Vec<String>) -> Result<()> {
    let mut normalised: Vec<String> = tags
        .into_iter()
        .map(|t| t.trim().to_lowercase())
        .filter(|t| !t.is_empty())
        .collect();
    normalised.sort();
    normalised.dedup();

    let tx = self.connection_mut().transaction()?;
    tx.execute("DELETE FROM note_tags WHERE note_id = ?", [note_id])?;
    for tag in &normalised {
        tx.execute(
            "INSERT INTO note_tags (note_id, tag) VALUES (?, ?)",
            rusqlite::params![note_id, tag],
        )?;
    }
    tx.commit()?;
    Ok(())
}
```

**Step 2: Add `get_all_tags`**

```rust
/// Returns all distinct tags used across the workspace, sorted alphabetically.
pub fn get_all_tags(&self) -> Result<Vec<String>> {
    let mut stmt = self.connection().prepare(
        "SELECT DISTINCT tag FROM note_tags ORDER BY tag"
    )?;
    let tags = stmt.query_map([], |row| row.get::<_, String>(0))?
        .collect::<rusqlite::Result<Vec<_>>>()?;
    Ok(tags)
}
```

**Step 3: Add `get_notes_for_tag`**

```rust
/// Returns all notes that have any of the provided tags (OR logic).
///
/// Returns an empty vec if `tags` is empty.
pub fn get_notes_for_tag(&self, tags: &[String]) -> Result<Vec<Note>> {
    if tags.is_empty() {
        return Ok(vec![]);
    }
    let placeholders = tags.iter().map(|_| "?").collect::<Vec<_>>().join(", ");
    let sql = format!(
        "SELECT n.id, n.title, n.node_type, n.parent_id, n.position,
                n.created_at, n.modified_at, n.created_by, n.modified_by,
                n.fields_json, n.is_expanded,
                GROUP_CONCAT(nt2.tag, ',') AS tags_csv
         FROM notes n
         JOIN note_tags nt ON nt.note_id = n.id AND nt.tag IN ({placeholders})
         LEFT JOIN note_tags nt2 ON nt2.note_id = n.id
         GROUP BY n.id
         ORDER BY n.parent_id, n.position"
    );
    let mut stmt = self.connection().prepare(&sql)?;
    let params: Vec<&dyn rusqlite::ToSql> = tags.iter()
        .map(|t| t as &dyn rusqlite::ToSql)
        .collect();
    let rows = stmt.query_map(params.as_slice(), map_note_row)?
        .collect::<rusqlite::Result<Vec<_>>>()?;
    rows.into_iter().map(note_from_row_tuple).collect()
}
```

**Step 4: Add tags to search filter in `list_all_notes` (or its search variant)**

Locate where the tree search is performed (likely a filtered variant of `list_all_notes` or in `workspace.rs`). The filter should match if `title + " " + tags.join(" ")` contains the query string (case-insensitive).

If there is no separate search method and the filter is applied on the Rust side after fetching all notes, update the filter predicate:

```rust
// Example: find where notes are filtered for search and change:
notes.retain(|n| n.title.to_lowercase().contains(&query_lower));
// to:
notes.retain(|n| {
    let searchable = format!("{} {}", n.title, n.tags.join(" ")).to_lowercase();
    searchable.contains(&query_lower)
});
```

**Step 5: Write tests**

```rust
#[test]
fn test_get_all_tags_empty() {
    let temp = NamedTempFile::new().unwrap();
    let ws = Workspace::create(temp.path(), "").unwrap();
    assert!(ws.get_all_tags().unwrap().is_empty());
}

#[test]
fn test_get_all_tags_sorted_distinct() {
    let temp = NamedTempFile::new().unwrap();
    let mut ws = Workspace::create(temp.path(), "").unwrap();
    let root = ws.list_all_notes().unwrap()[0].clone();
    let child_id = ws.create_note(&root.id, AddPosition::AsChild, "TextNote").unwrap();
    ws.update_note_tags(&root.id, vec!["rust".into(), "design".into()]).unwrap();
    ws.update_note_tags(&child_id, vec!["rust".into(), "testing".into()]).unwrap();
    let tags = ws.get_all_tags().unwrap();
    assert_eq!(tags, vec!["design", "rust", "testing"]);
}

#[test]
fn test_get_notes_for_tag() {
    let temp = NamedTempFile::new().unwrap();
    let mut ws = Workspace::create(temp.path(), "").unwrap();
    let root = ws.list_all_notes().unwrap()[0].clone();
    let child_id = ws.create_note(&root.id, AddPosition::AsChild, "TextNote").unwrap();
    ws.update_note_tags(&root.id, vec!["rust".into()]).unwrap();
    ws.update_note_tags(&child_id, vec!["design".into()]).unwrap();

    let rust_notes = ws.get_notes_for_tag(&["rust".into()]).unwrap();
    assert_eq!(rust_notes.len(), 1);
    assert_eq!(rust_notes[0].id, root.id);

    // OR logic: both notes returned when both tags queried
    let both = ws.get_notes_for_tag(&["rust".into(), "design".into()]).unwrap();
    assert_eq!(both.len(), 2);

    // Unknown tag returns empty
    let none = ws.get_notes_for_tag(&["unknown".into()]).unwrap();
    assert!(none.is_empty());
}

#[test]
fn test_update_note_tags_replaces_existing() {
    let temp = NamedTempFile::new().unwrap();
    let mut ws = Workspace::create(temp.path(), "").unwrap();
    let root = ws.list_all_notes().unwrap()[0].clone();
    ws.update_note_tags(&root.id, vec!["old".into()]).unwrap();
    ws.update_note_tags(&root.id, vec!["new".into()]).unwrap();
    let tags = ws.get_all_tags().unwrap();
    assert_eq!(tags, vec!["new"]); // "old" removed
}

#[test]
fn test_update_note_tags_normalises() {
    let temp = NamedTempFile::new().unwrap();
    let mut ws = Workspace::create(temp.path(), "").unwrap();
    let root = ws.list_all_notes().unwrap()[0].clone();
    ws.update_note_tags(&root.id, vec!["  Rust  ".into(), "RUST".into(), "rust".into()]).unwrap();
    let note = ws.get_note(&root.id).unwrap();
    assert_eq!(note.tags, vec!["rust"]); // deduped, lowercased, trimmed
}
```

**Step 6: Run all tests**

```bash
cargo test -p krillnotes-core -- --nocapture
```

Expected: all PASS.

**Step 7: Commit**

```bash
git add krillnotes-core/src/core/workspace.rs
git commit -m "feat(tags): add update_note_tags, get_all_tags, get_notes_for_tag"
```

---

## Task 6: Expose tags API as Tauri commands

**Files:**
- Modify: `krillnotes-desktop/src-tauri/src/lib.rs`

**Step 1: Add `update_note_tags` command**

Find a good location near the `update_note` command. Add:

```rust
#[tauri::command]
pub async fn update_note_tags(
    window: tauri::Window,
    state: State<'_, AppState>,
    note_id: String,
    tags: Vec<String>,
) -> std::result::Result<(), String> {
    let label = window.label().to_string();
    let mut workspaces = state.workspaces.lock().map_err(|e| e.to_string())?;
    let ws = workspaces.get_mut(&label)
        .ok_or_else(|| "No workspace open".to_string())?;
    ws.update_note_tags(&note_id, tags).map_err(|e| e.to_string())
}
```

**Step 2: Add `get_all_tags` command**

```rust
#[tauri::command]
pub async fn get_all_tags(
    window: tauri::Window,
    state: State<'_, AppState>,
) -> std::result::Result<Vec<String>, String> {
    let label = window.label().to_string();
    let workspaces = state.workspaces.lock().map_err(|e| e.to_string())?;
    let ws = workspaces.get(&label)
        .ok_or_else(|| "No workspace open".to_string())?;
    ws.get_all_tags().map_err(|e| e.to_string())
}
```

**Step 3: Add `get_notes_for_tag` command**

```rust
#[tauri::command]
pub async fn get_notes_for_tag(
    window: tauri::Window,
    state: State<'_, AppState>,
    tags: Vec<String>,
) -> std::result::Result<Vec<Note>, String> {
    let label = window.label().to_string();
    let workspaces = state.workspaces.lock().map_err(|e| e.to_string())?;
    let ws = workspaces.get(&label)
        .ok_or_else(|| "No workspace open".to_string())?;
    ws.get_notes_for_tag(&tags).map_err(|e| e.to_string())
}
```

**Step 4: Register the commands**

Find the `tauri::Builder` `.invoke_handler(tauri::generate_handler![...])` call in `lib.rs` and add the three new commands to the list.

**Step 5: Build to verify no compile errors**

```bash
cargo build -p krillnotes-desktop 2>&1 | tail -20
```

Expected: no errors.

**Step 6: Commit**

```bash
git add krillnotes-desktop/src-tauri/src/lib.rs
git commit -m "feat(tags): expose update_note_tags, get_all_tags, get_notes_for_tag as Tauri commands"
```

---

## Task 7: Add `tags` to frontend `Note` type

**Files:**
- Modify: `krillnotes-desktop/src/types.ts`

**Step 1: Add field**

```ts
export interface Note {
  id: string;
  title: string;
  nodeType: string;
  parentId: string | null;
  position: number;
  createdAt: number;
  modifiedAt: number;
  createdBy: number;
  modifiedBy: number;
  fields: Record<string, FieldValue>;
  isExpanded: boolean;
  tags: string[];   // new
}
```

**Step 2: Fix TypeScript build**

```bash
cd krillnotes-desktop && npm run build 2>&1 | head -40
```

Fix any TypeScript errors (anywhere `Note` is constructed without `tags` â€” add `tags: []`).

**Step 3: Commit**

```bash
git add krillnotes-desktop/src/types.ts
git commit -m "feat(tags): add tags field to frontend Note type"
```

---

## Task 8: Tag pill color utility

**Files:**
- Create: `krillnotes-desktop/src/utils/tagColor.ts`

This utility is shared between the editor, the default view, and the tag cloud.

**Step 1: Create the file**

```ts
/**
 * Returns a deterministic HSL background color for a tag.
 * Hue is derived from the sum of the tag's char codes, giving the same
 * tag the same color across renders and sessions.
 */
export function tagColor(tag: string): string {
  const hue = [...tag].reduce((acc, c) => acc + c.charCodeAt(0), 0) % 360;
  return `hsl(${hue}, 40%, 88%)`;
}
```

**Step 2: Commit**

```bash
git add krillnotes-desktop/src/utils/tagColor.ts
git commit -m "feat(tags): add deterministic tagColor utility"
```

---

## Task 9: Tag pill component

**Files:**
- Create: `krillnotes-desktop/src/components/TagPill.tsx`
- Modify: `krillnotes-desktop/src/App.css` (or equivalent global CSS)

**Step 1: Create `TagPill.tsx`**

```tsx
import { tagColor } from '../utils/tagColor';

interface TagPillProps {
  tag: string;
  onRemove?: () => void;   // if provided, shows Ã— button (edit mode)
  onClick?: () => void;    // if provided, pill is clickable (tag cloud)
}

export default function TagPill({ tag, onRemove, onClick }: TagPillProps) {
  return (
    <span
      className={`kn-tag-pill${onClick ? ' kn-tag-pill--clickable' : ''}`}
      style={{ backgroundColor: tagColor(tag) }}
      onClick={onClick}
      title={tag}
    >
      {tag}
      {onRemove && (
        <button
          className="kn-tag-pill__remove"
          onClick={e => { e.stopPropagation(); onRemove(); }}
          aria-label={`Remove tag ${tag}`}
        >
          Ã—
        </button>
      )}
    </span>
  );
}
```

**Step 2: Add CSS**

Add to the app's global CSS file (wherever `.kn-view-*` classes are defined):

```css
.kn-tag-pill {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 0.75rem;
  font-weight: 500;
  color: #333;
  white-space: nowrap;
  user-select: none;
}
.kn-tag-pill--clickable {
  cursor: pointer;
}
.kn-tag-pill--clickable:hover {
  filter: brightness(0.93);
}
.kn-tag-pill__remove {
  background: none;
  border: none;
  padding: 0;
  cursor: pointer;
  font-size: 0.9rem;
  line-height: 1;
  color: #555;
  display: flex;
  align-items: center;
}
.kn-tag-pill__remove:hover {
  color: #000;
}
.kn-view-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-bottom: 12px;
}
```

**Step 3: Commit**

```bash
git add krillnotes-desktop/src/components/TagPill.tsx krillnotes-desktop/src/App.css
git commit -m "feat(tags): add TagPill component and CSS"
```

---

## Task 10: Tag editor in `InfoPanel` (edit mode)

**Files:**
- Modify: `krillnotes-desktop/src/components/InfoPanel.tsx`

The tag editor appears between the title input and the schema fields when `isEditing` is true. It manages a local `editedTags` state and fetches the global tag list once on entering edit mode for autocomplete.

**Step 1: Add state**

In `InfoPanel`, add:

```ts
const [editedTags, setEditedTags] = useState<string[]>([]);
const [allTags, setAllTags] = useState<string[]>([]);
const [tagInput, setTagInput] = useState('');
const [tagSuggestions, setTagSuggestions] = useState<string[]>([]);
```

**Step 2: Populate `editedTags` when note changes**

In the `useEffect` that fires when `selectedNote` changes, set:

```ts
setEditedTags(selectedNote?.tags ?? []);
```

**Step 3: Fetch `allTags` when entering edit mode**

When `isEditing` becomes `true`, invoke:

```ts
invoke<string[]>('get_all_tags').then(setAllTags).catch(console.error);
```

**Step 4: Add `addTag` / `removeTag` helpers**

```ts
function addTag(tag: string) {
  const normalised = tag.trim().toLowerCase();
  if (!normalised || editedTags.includes(normalised)) return;
  setEditedTags(prev => [...prev, normalised].sort());
  setTagInput('');
  setTagSuggestions([]);
}

function removeTag(tag: string) {
  setEditedTags(prev => prev.filter(t => t !== tag));
}
```

**Step 5: Wire `tagInput` to suggestions**

```ts
function handleTagInputChange(value: string) {
  setTagInput(value);
  if (!value.trim()) {
    setTagSuggestions([]);
    return;
  }
  const lower = value.trim().toLowerCase();
  setTagSuggestions(
    allTags.filter(t => t.includes(lower) && !editedTags.includes(t)).slice(0, 8)
  );
}
```

**Step 6: Add tag editor JSX**

Insert between the title input and the fields section inside the edit-mode render:

```tsx
{/* Tag editor */}
<div className="kn-tag-editor">
  <div className="kn-tag-editor__pills">
    {editedTags.map(tag => (
      <TagPill key={tag} tag={tag} onRemove={() => removeTag(tag)} />
    ))}
  </div>
  <div className="kn-tag-editor__input-wrap">
    <input
      className="kn-tag-editor__input"
      placeholder="Add tagâ€¦"
      value={tagInput}
      onChange={e => handleTagInputChange(e.target.value)}
      onKeyDown={e => {
        if (e.key === 'Enter' || e.key === 'Tab') {
          e.preventDefault();
          if (tagSuggestions.length > 0) addTag(tagSuggestions[0]);
          else if (tagInput.trim()) addTag(tagInput);
        }
      }}
    />
    {tagSuggestions.length > 0 && (
      <ul className="kn-tag-editor__suggestions">
        {tagSuggestions.map(t => (
          <li key={t} onMouseDown={() => addTag(t)}>{t}</li>
        ))}
      </ul>
    )}
  </div>
</div>
```

**Step 7: Save tags on note save**

In the save handler (wherever `invoke('update_note', ...)` is called), also call:

```ts
await invoke('update_note_tags', { noteId: selectedNote!.id, tags: editedTags });
```

**Step 8: Add CSS for the tag editor**

```css
.kn-tag-editor {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-bottom: 16px;
}
.kn-tag-editor__pills {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}
.kn-tag-editor__input-wrap {
  position: relative;
}
.kn-tag-editor__input {
  width: 100%;
  padding: 4px 8px;
  font-size: 0.85rem;
  border: 1px solid var(--border-color, #ccc);
  border-radius: 6px;
  background: var(--input-bg, #fff);
}
.kn-tag-editor__suggestions {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: var(--panel-bg, #fff);
  border: 1px solid var(--border-color, #ccc);
  border-radius: 6px;
  list-style: none;
  margin: 2px 0 0;
  padding: 4px 0;
  z-index: 100;
  max-height: 180px;
  overflow-y: auto;
}
.kn-tag-editor__suggestions li {
  padding: 4px 10px;
  cursor: pointer;
  font-size: 0.85rem;
}
.kn-tag-editor__suggestions li:hover {
  background: var(--hover-bg, #f0f0f0);
}
```

**Step 9: Build and manually verify**

```bash
cd krillnotes-desktop && npm run build
```

Open a workspace, select a note, enter edit mode, add/remove tags, save â€” verify tags persist on the note.

**Step 10: Commit**

```bash
git add krillnotes-desktop/src/components/InfoPanel.tsx krillnotes-desktop/src/App.css
git commit -m "feat(tags): tag pill editor in InfoPanel edit mode"
```

---

## Task 11: Tags in default note view

**Files:**
- Modify: `krillnotes-desktop/src/components/InfoPanel.tsx`

**Step 1: Render tags in view mode**

In the view-mode render section of `InfoPanel`, before the schema fields (or before the custom view HTML), insert:

```tsx
{selectedNote.tags.length > 0 && (
  <div className="kn-view-tags">
    {selectedNote.tags.map(tag => (
      <TagPill key={tag} tag={tag} />
    ))}
  </div>
)}
```

The `.kn-view-tags` CSS was added in Task 9.

**Step 2: Verify**

Add tags to a note, save, view it â€” tags should appear as coloured pills above the fields.

**Step 3: Commit**

```bash
git add krillnotes-desktop/src/components/InfoPanel.tsx
git commit -m "feat(tags): show tag pills in default note view"
```

---

## Task 12: Scripting â€” `render_tags` display helper

**Files:**
- Modify: `krillnotes-core/src/core/scripting/display_helpers.rs`
- Modify: `krillnotes-core/src/core/scripting/mod.rs` (register the function)

**Step 1: Add `render_tags` to `display_helpers.rs`**

The color formula mirrors the frontend (`tagColor` utility): hue = sum of char codes % 360.

```rust
/// Rhai host function: renders an array of tag strings as coloured pill HTML.
///
/// ```rhai
/// on_view("Note", |note| {
///     render_tags(note.tags)
/// });
/// ```
pub fn rhai_render_tags(tags: Array) -> String {
    let pills: String = tags.iter().map(|d| {
        let tag = d.to_string();
        let hue: u32 = tag.bytes().map(|b| b as u32).sum::<u32>() % 360;
        let escaped = html_escape(&tag);
        format!(
            "<span class=\"kn-tag-pill\" style=\"background:hsl({hue},40%,88%)\">{escaped}</span>"
        )
    }).collect();
    format!("<div class=\"kn-view-tags\">{pills}</div>")
}
```

**Step 2: Register in the Rhai engine**

In `scripting/mod.rs`, find where `rhai_markdown`, `section`, etc. are registered (look for `engine.register_fn(...)`). Add:

```rust
engine.register_fn("render_tags", display_helpers::rhai_render_tags);
```

**Step 3: Write a test**

In `display_helpers.rs` tests:

```rust
#[test]
fn test_render_tags_empty() {
    let result = rhai_render_tags(vec![]);
    assert_eq!(result, "<div class=\"kn-view-tags\"></div>");
}

#[test]
fn test_render_tags_escapes_html() {
    let tags = vec![Dynamic::from("<b>evil</b>".to_string())];
    let result = rhai_render_tags(tags);
    assert!(result.contains("&lt;b&gt;evil&lt;/b&gt;"));
    assert!(!result.contains("<b>"));
}

#[test]
fn test_render_tags_color_is_deterministic() {
    let tags1 = vec![Dynamic::from("rust".to_string())];
    let tags2 = vec![Dynamic::from("rust".to_string())];
    assert_eq!(rhai_render_tags(tags1), rhai_render_tags(tags2));
}
```

**Step 4: Run tests**

```bash
cargo test -p krillnotes-core -- --nocapture
```

Expected: all pass.

**Step 5: Commit**

```bash
git add krillnotes-core/src/core/scripting/display_helpers.rs \
        krillnotes-core/src/core/scripting/mod.rs
git commit -m "feat(tags): add render_tags() Rhai display helper"
```

---

## Task 13: Scripting â€” `get_notes_for_tag` query function

**Files:**
- Modify: `krillnotes-core/src/core/scripting/mod.rs`

**Context:** `on_view` hooks have access to query functions like `get_children`. Adding `get_notes_for_tag` follows the same pattern. Look at how `get_children` is exposed to Rhai via a closure that captures a reference to the `QueryContext` or calls back into the workspace.

**Step 1: Add the Rhai function registration**

Find the block in `scripting/mod.rs` where Rhai host functions that query notes are registered. Add `get_notes_for_tag` using the same Arc/Mutex pattern:

```rust
// Inside the engine setup block where query functions are registered:
let ws_arc_tags = workspace_arc.clone(); // workspace_arc is whatever Arc<Mutex<&Workspace>> is used
engine.register_fn("get_notes_for_tag", move |tags: rhai::Array| -> rhai::Array {
    let tag_strs: Vec<String> = tags.iter().map(|d| d.to_string()).collect();
    let ws = ws_arc_tags.lock().unwrap();
    match ws.get_notes_for_tag(&tag_strs) {
        Ok(notes) => notes.iter().map(note_to_rhai_dynamic).collect(),
        Err(e) => {
            eprintln!("[krillnotes] get_notes_for_tag error: {e}");
            vec![]
        }
    }
});
```

> **Note:** The exact pattern depends on how the workspace reference is captured for `on_view` hooks. Look at how `get_children` or `get_note` is registered in `run_on_view_hook` or `build_engine_for_view` and follow the identical pattern. The function closure must capture the workspace (or its connection) in the same way.

**Step 2: Run all tests**

```bash
cargo test -p krillnotes-core -- --nocapture
```

Expected: all pass.

**Step 3: Commit**

```bash
git add krillnotes-core/src/core/scripting/mod.rs
git commit -m "feat(tags): expose get_notes_for_tag() in Rhai on_view hooks"
```

---

## Task 14: Tag cloud panel in tree view

**Files:**
- Modify: `krillnotes-desktop/src/components/WorkspaceView.tsx`
- Modify: `krillnotes-desktop/src/App.css`

**Step 1: Add state**

```ts
const [tagCloudHeight, setTagCloudHeight] = useState(120); // px
const [workspaceTags, setWorkspaceTags] = useState<string[]>([]);
const isTagDragging = useRef(false);
const tagDragStartY = useRef(0);
const tagDragStartHeight = useRef(0);
```

**Step 2: Fetch tags on mount and after note saves**

Call `get_all_tags` wherever `loadNotes` is called (mount and after mutations):

```ts
invoke<string[]>('get_all_tags').then(setWorkspaceTags).catch(console.error);
```

**Step 3: Add drag handler for tag cloud resize**

```ts
const handleTagDividerMouseDown = useCallback((e: React.MouseEvent) => {
  isTagDragging.current = true;
  tagDragStartY.current = e.clientY;
  tagDragStartHeight.current = tagCloudHeight;
  e.preventDefault();
}, [tagCloudHeight]);

useEffect(() => {
  const onMouseMove = (e: MouseEvent) => {
    if (!isTagDragging.current) return;
    // Dragging up increases height (divider is at top of cloud)
    const delta = tagDragStartY.current - e.clientY;
    setTagCloudHeight(Math.max(0, Math.min(400, tagDragStartHeight.current + delta)));
  };
  const onMouseUp = () => { isTagDragging.current = false; };
  document.addEventListener('mousemove', onMouseMove);
  document.addEventListener('mouseup', onMouseUp);
  return () => {
    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('mouseup', onMouseUp);
  };
}, []);
```

**Step 4: Handle tag cloud pill click**

Clicking a tag in the tag cloud sets the search bar to that tag. Find the existing `setSearchQuery` (or equivalent) state setter and connect:

```ts
function handleTagCloudClick(tag: string) {
  setSearchQuery(tag); // triggers tree filter (tags are now in the search text)
}
```

**Step 5: Add tag cloud JSX to the tree column**

In the render, find the tree column container. Replace:

```tsx
<div ref={treePanelRef} style={{ width: treeWidth, ... }}>
  <SearchBar ... />
  <TreeView ... />
</div>
```

with:

```tsx
<div ref={treePanelRef} style={{ width: treeWidth, display: 'flex', flexDirection: 'column', ... }}>
  <SearchBar ... />
  <TreeView ... />  {/* flex-grow: 1 so it takes remaining space */}

  {/* Horizontal drag handle */}
  <div className="kn-tag-divider" onMouseDown={handleTagDividerMouseDown} />

  {/* Tag cloud */}
  <div
    className="kn-tag-cloud"
    style={{ height: tagCloudHeight, overflow: tagCloudHeight === 0 ? 'hidden' : 'auto' }}
  >
    {workspaceTags.map(tag => (
      <TagPill key={tag} tag={tag} onClick={() => handleTagCloudClick(tag)} />
    ))}
    {workspaceTags.length === 0 && (
      <span className="kn-tag-cloud__empty">No tags yet</span>
    )}
  </div>
</div>
```

**Step 6: Add CSS**

```css
.kn-tag-divider {
  height: 4px;
  cursor: row-resize;
  background: var(--divider-color, #e0e0e0);
  flex-shrink: 0;
}
.kn-tag-divider:hover {
  background: var(--divider-hover-color, #bbb);
}
.kn-tag-cloud {
  display: flex;
  flex-wrap: wrap;
  align-content: flex-start;
  gap: 6px;
  padding: 8px;
  flex-shrink: 0;
}
.kn-tag-cloud__empty {
  font-size: 0.75rem;
  color: var(--muted-color, #999);
}
```

**Step 7: Build and manually verify**

- Tag cloud appears at the bottom of the tree
- Drag handle resizes it
- Clicking a tag filters the tree to notes containing that tag

**Step 8: Commit**

```bash
git add krillnotes-desktop/src/components/WorkspaceView.tsx krillnotes-desktop/src/App.css
git commit -m "feat(tags): add resizable tag cloud panel to tree view"
```

---

## Task 15: Export â€” add `workspace.json`

**Files:**
- Modify: `krillnotes-core/src/core/export.rs`
- Modify: `krillnotes-core/src/core/workspace.rs` (import side: read note tags from `Note.tags`)

**Step 1: Add `WorkspaceJson` struct to `export.rs`**

```rust
/// Top-level JSON structure in `workspace.json`.
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct WorkspaceJson {
    pub version: u32,
    /// Complete sorted list of distinct tags across the workspace.
    pub tags: Vec<String>,
}
```

**Step 2: Write `workspace.json` in `export_workspace`**

After writing `notes.json`, add:

```rust
// Write workspace.json
let all_tags = workspace.get_all_tags()
    .map_err(|e| ExportError::Database(e.to_string()))?;
let workspace_json = WorkspaceJson {
    version: 1,
    tags: all_tags,
};
zip.start_file("workspace.json", options)?;
serde_json::to_writer_pretty(&mut zip, &workspace_json)?;
```

**Step 3: Restore note tags during `import_workspace`**

In the note bulk-insert loop, after inserting each note, insert its tags:

```rust
for note in &export_notes.notes {
    let fields_json = serde_json::to_string(&note.fields)?;
    tx.execute(
        "INSERT INTO notes ... VALUES (?, ?, ..., ?)",
        rusqlite::params![/* existing params */],
    ).map_err(|e| ExportError::Database(e.to_string()))?;

    // Insert tags for this note
    for tag in &note.tags {
        tx.execute(
            "INSERT OR IGNORE INTO note_tags (note_id, tag) VALUES (?, ?)",
            rusqlite::params![note.id, tag],
        ).map_err(|e| ExportError::Database(e.to_string()))?;
    }
}
```

**Step 4: Write failing test**

```rust
#[test]
fn test_export_includes_workspace_json() {
    let temp = NamedTempFile::new().unwrap();
    let mut ws = Workspace::create(temp.path(), "").unwrap();
    let root = ws.list_all_notes().unwrap()[0].clone();
    ws.update_note_tags(&root.id, vec!["rust".into(), "design".into()]).unwrap();

    let mut buf = Vec::new();
    export_workspace(&ws, Cursor::new(&mut buf), None).unwrap();

    let mut archive = zip::ZipArchive::new(Cursor::new(&buf)).unwrap();
    let ws_file = archive.by_name("workspace.json").unwrap();
    let ws_json: WorkspaceJson = serde_json::from_reader(ws_file).unwrap();
    assert_eq!(ws_json.version, 1);
    assert_eq!(ws_json.tags, vec!["design", "rust"]);
}

#[test]
fn test_round_trip_preserves_tags() {
    let temp_src = NamedTempFile::new().unwrap();
    let mut ws = Workspace::create(temp_src.path(), "").unwrap();
    let root = ws.list_all_notes().unwrap()[0].clone();
    ws.update_note_tags(&root.id, vec!["rust".into()]).unwrap();

    let mut buf = Vec::new();
    export_workspace(&ws, Cursor::new(&mut buf), None).unwrap();

    let temp_dst = NamedTempFile::new().unwrap();
    import_workspace(Cursor::new(&buf), temp_dst.path(), None, "").unwrap();

    let imported = Workspace::open(temp_dst.path(), "").unwrap();
    let tags = imported.get_all_tags().unwrap();
    assert_eq!(tags, vec!["rust"]);
}
```

**Step 5: Run tests**

```bash
cargo test -p krillnotes-core -- --nocapture
```

Expected: all pass.

**Step 6: Commit**

```bash
git add krillnotes-core/src/core/export.rs krillnotes-core/src/core/workspace.rs
git commit -m "feat(tags): add workspace.json to export, restore tags on import"
```

---

## Task 16: Final build, smoke test, and PR

**Step 1: Full build**

```bash
cargo build -p krillnotes-core -p krillnotes-desktop 2>&1 | tail -20
```

**Step 2: Run all Rust tests**

```bash
cargo test -- --nocapture 2>&1 | tail -30
```

Expected: all pass, no regressions.

**Step 3: Frontend build**

```bash
cd krillnotes-desktop && npm run build
```

Expected: no TypeScript errors.

**Step 4: Smoke test checklist (manual)**

- [ ] Add tags to a note in the editor â€” pills appear, save persists them
- [ ] View mode shows tag pills with correct colors (same tag = same color)
- [ ] Tag cloud appears at the bottom of the tree; drag handle resizes it
- [ ] Clicking a tag in the cloud filters the tree to notes with that tag
- [ ] Search bar finds notes by tag text
- [ ] Export a workspace â€” open zip and confirm `workspace.json` contains the tags
- [ ] Import the zip into a fresh workspace â€” tags are restored on notes

**Step 5: Push and open PR**

```bash
git push -u origin feat/tags
gh pr create --title "feat: add tags to notes (issue #13)" --body "$(cat <<'EOF'
## Summary

- Adds first-class `tags: Vec<String>` to the `Note` struct, backed by a `note_tags` junction table
- Tag CRUD: `update_note_tags`, `get_all_tags`, `get_notes_for_tag` (Rust + Tauri commands)
- Tag pill editor in `InfoPanel` edit mode (autocomplete from existing tags)
- Tags render as deterministic-color pills in the default note view
- Scripting: `render_tags(tags)` display helper and `get_notes_for_tag(tags)` query function in `on_view` hooks
- Resizable tag cloud panel at the bottom of the tree; clicking a tag filters the tree
- Tags included in tree search matching
- Export writes `workspace.json` with global tag list; import restores note tags

Closes #13

## Test plan

- [ ] All Rust unit tests pass (`cargo test`)
- [ ] No TypeScript build errors
- [ ] Manual smoke test checklist in Task 16 complete

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
EOF
)"
```
